---
title: 计算机网络
order: 1
---

# 计算机网络

## 基础篇

### 常见的 HTTP 请求方法

**GET：** 获取资源

**POST：** 提交资源

**PUT：** 提交并修改资源

**PATCH：** 对资源部分修改

**OPTIONS：** 探头，用来探测是否支持请求方法、跨域、安全

**CONNECT：** 与代理服务器建立管道，使用管道进行 TCP 通信

**TRACE：** 让服务器原样返回客户端的请求信息内容，用于测试或诊断

### 页面从输入 URL 后发生啥？

1. **DNS 解析**：浏览器先从 URL 中获取域名，然后将域名发送给 DNS 服务器进行解析，获取目标服务器的 IP 地址。
2. **建立 TCP 连接**：浏览器通过获取的 IP 地址和端口号，向目标服务器发起 TCP 连接请求，并等待服务器回应。
3. **发送 HTTP 请求**：TCP 连接建立后，浏览器向服务器发送 HTTP 请求，请求内容包括请求行、请求头和请求体。
4. **服务器响应**：服务器接收到请求后，开始处理请求并返回响应数据。响应数据包括响应头和响应体。
5. **浏览器解析渲染页面**：浏览器接收到响应数据后，开始对数据进行解析。 HTML 解析器和 CSS 解析器并行构建**DOM 树**和**CSS 树**，然后结合成**CSSOM 树** ，JS 引擎运行 JS 代码，进行 DOM 的操作或修改。然后进行 UI 布局、绘制，进而将整个页面渲染出来
6. **断开连接**：当所有内容都加载完成后，浏览器关闭与服务器的 TCP 连接，页面加载完毕。

### 什么是 WebSocket？

`WebSocket`是一种网络通信协议，是在 TCP 连接上进行全双工通信的协议。

`Websocket`可以实现客户端和服务端之间进行全双工通信，任何一方都可以通过建立连接将数据传到另一端，它只需要建立一次连接，就可以一直保持连接状态

### 队头阻塞

### HTTP 状态码有哪些状态码

**1XX：** 信息类状态码

**2XX：** 成功状态码

**3XX：** 重定向状态码

**4XX：** 请求错误状态码

**5XX：** 服务端错误状态码

**2XX**

- **200：** 成功处理请求
- **201：** 成功创建，一般应用在 POST
- **202：** 服务端接收请求，但尚未处理，不保证完成请求
- **204：** 请求成功，但是相应爆文不含实体的主体部分

**3XX**

- **301：** 永久性重定向
- **302：** 临时重定向
- **304：** 协商缓存命中

**4XX**

- **400：** 请求内容存在语法错误
- **401：** 请求无权限
- **403：** 请求资源被服务端拒绝
- **404：** 无法找到请求的资源

**5XX**

- **500：** 服务器报错
- **501：** 服务端不支持当前请求所需要的某个功能
- **503：** 服务器暂时处于超负载或停机维护，无法处理请求

### 什么是 DNS？并说明 DNS 解析过程

`DNS（Domain Name System）域名系统`，**把请求域名转换成 IP**

在浏览器中输入一个域名，解析流程如下：

1. 客户端发送一个 DNS**查询请求到本地 DNS 服务器**。本地 DNS 服务器**已经缓存**该域名对应的 IP 地址，则它会直接返回该 IP 地址给客户端，否则将向其他 DNS 服务器发起请求。
2. 如果没有，将向**根域名服务器**发出请求。查询**该域名的顶级域名服务器的 IP 地址**。
3. 获取到顶级域名服务器 IP 地址，它将**向该域名对应顶级域名服务器发起请求**。
4. 顶级域名服务器将向本地 DNS 服务器**提供下一级域名服务器的 IP 地址**。
5. 过程将一直继续，**直到本地 DNS 服务器找到该域名对应的 IP 地址**。一旦本地 DNS 服务器**找到了**该域名对应的 IP 地址，它将把该**IP 地址缓存**起来，并将其返回给客户端。
6. 如果都没找到，则解析失败。通常是由于域名不存在、DNS 服务器出现故障、网络连接问题等原因导致的。

### 介绍三次握手，为什么需要三次

TCP 协议使用三次握手（Three-Way Handshake）建立一个可靠的连接，确保通信双方的数据传输是可靠的。

三次握手的过程如下：

1. **客户端向服务器发送一个 SYN 包**，请求建立连接。该包包含一个随机序列号（ISN），用于标识该连接。**客户端进入 SYN_SENT 状态** ，等待服务器的响应。
2. **服务器接收到 SYN 包后**，向客户端**发送一个 SYN+ACK 包**，表示收到请求并确认建立连接。该包也包含一个随机序列号（ISN），用于标识该连接。**服务器进入 SYN_RCVD 状态**。
3. **客户端接收到 SYN+ACK 包后**，向服务器**发送一个 ACK 包**，表示确认建立连接。该包也包含一个随机序列号（ISN），用于标识该连接。**客户端进入 ESTABLISHED 状态**，**服务器在接收到该 ACK 包后，也进入 ESTABLISHED 状态**。从此，两个端点可以开始进行数据传输。

解释一下为什么需要三次握手。

第一次握手：由**客户端**发送 SYN 包，**请求连接**。

此时，客户端并不知道服务器是否准备好建立连接，服务器也不知道客户端是否真的要建立连接。因此，**第一次握手的目的是让服务器知道客户端的存在，并打开接收数据的端口。**

第二次握手：**服务器**发送 SYN+ACK 包，**表示确认请求，并告诉客户端可以向该端口发送数据**。

此时，服务器知道了客户端的请求，并打开了一个新的端口等待数据传输。

第三次握手：**客户端**发送 ACK 包，**确认可以向服务器发送数据**。

此时，客户端知道了服务器的存在，并且知道了服务器可以接收数据的端口。这样，双方都知道了对方的存在，并确认了可以进行数据传输，从而建立了可靠的连接。

总之，三次握手的目的是为了确保通信双方都能够收到对方的请求和确认，并且都准备好进行数据传输。它可以避免因为网络延迟或其他原因导致连接失败或不可靠，从而确保通信的可靠性。

补充：`SYN、ISN、ACK`

`SYN（Synchronize Sequence Number）`：同步序列号。TCP 通信的建立需要三次握手，SYN 字段用于在建立连接时发起请求。

`ISN（Initial Sequence Number）`：初始序列号。ISN 是由随机数生成的一个 32 位数值，用于标识 TCP 报文段中第一个字节的序列号，从而实现有序传输。

`ACK（Acknowledgment Number）`：确认序列号。ACK 用于确认接收方已经成功接收到序列号为 ISN 的报文段，并且告诉发送方下一个期望收到的报文段的序列号。

### 介绍四次挥手，为什么需要四次

TCP 协议使用四次挥手（Four-Way Handshake）来终止一个 TCP 连接。

四次挥手的过程如下：

1. **客户端**向服务器**发送一个 FIN 包**，请求关闭连接。**客户端进入 FIN_WAIT_1 状态**。
2. **服务器**接**收到 FIN** 包后，**向客户端发送一个 ACK 包**，表示确认关闭连接。**服务器进入 CLOSE_WAIT 状态**。
3. **服务器**向客户端**发送一个 FIN 包**，请求关闭连接。**服务器进入 LAST_ACK 状态**。
4. **客户端**接**收到 FIN 包后**，向服务器**发送一个 ACK 包**，表示确认关闭连接。**客户端进入 TIME_WAIT 状态**，等待 2 个 MSL（Maximum Segment Lifetime）时间，确保服务器已经收到了最后一个 ACK 包。

解释一下为什么需要四次挥手。

首先，由于 TCP 协议的全双工特性。在 TCP 连接建立后，通信双方都可以向对方发送数据，并接收对方发送的数据。当其中一方要关闭连接时，它**不能只单方面地终止连接**，因为另一方仍然可能在发送数据。因此，需要四次挥手来确保两端都知道对方已经关闭连接。

第一次挥手：由**客户端发送 FIN 包**，请求关闭连接。此时，客户端没有数据要发送给服务器了，并告诉服务器可以关闭连接了。

第二次挥手：由**服务器**向客户端**发送一个 ACK 包**，**确认收到了客户端的 FIN 包**，并告诉客户端可以关闭连接了。但是，服务器仍然可以向客户端发送数据，因此**服务器进入 CLOSE_WAIT 状态**。

第三次挥手：服务器数据发送完成后，由**服务器**向客户端**发送 FIN 包**，告诉客户端可以关闭连接了。此时，**服务器进入 LAST_ACK 状态**，等待客户端的确认。

第四次挥手：由**客户端**向服务器**发送一个 ACK 包**，**确认收到了服务器的 FIN 包**，并告诉服务器可以关闭连接了。客户端进入 TIME_WAIT 状态，**等待 2 个 MSL 时间**，确保服务器已经收到了最后一个 ACK 包。

这个等待时间是为了确保在网络传输过程中可能出现的延迟 ACK 包能够被接收，从而确保连接被完全终止。

总之，四次挥手的目的是为了确保通信双方都知道对方已经关闭连接，并且在关闭连接前完成了所有数据传输。它可以避免数据丢失或不完整，从而确保连接的可靠性。

补充：`FIN、MSL`

`FIN（Finish）`:是 TCP 协议用来结束一次连接的标志，通常由客户端或服务器端发起，用于向对方发出结束连接的请求。

`MSL（Maximum Segment Lifetime）`：网络中数据包在网络上可以存活的最长时间。

补充：等待 2 个 MSL 原因

当客户端发送最后一个 ACK 报文段后，可能还有**一些数据包在互联网中滞留**，这些数据包可能因为各种原因，没有到达对端，从而**导致对端没有接收到客户端的 ACK，会触发对端的超时重传机制，从而导致连接无法释放**。

为了避免这种情况发生，**TCP 协议中规定，等待 2 倍的最大报文段生存时间(MSL)，可以确保互联网中的所有数据包都被丢弃**，从而保证连接可以安全地释放。

### 计算机网络五层模型

计算机网络五层模型是指将网络通信分为五个层次，**从下到上**分别是**物理层、数据链路层、网络层、传输层和应用层**。该模型是 TCP/IP 协议族的基础，其各层的功能如下：

物理层（`Physical Layer`）：负责数据在**物理媒介中的传输**，如电缆、光纤等，主要涉及传输的物理特性，如电压、电流、频率等。

数据链路层（`Data Link Layer`）：**将物理层传输的比特流组成帧，并进行传输错误检测和纠正**，如 MAC 地址的识别、流量控制等，确保数据的正确性和完整性。

网络层（`Network Layer`）：负责**数据在网络中的传输和路由选择**，如 IP 协议，实现数据包的传输和地址的分配等功能。

传输层（`Transport Layer`）：负责数据在**端到端之间的传输和可靠性控制**，如 TCP、UDP 协议，提供数据的分段、传输确认等功能。

应用层（`Application Layer`）：**为用户提供服务**，包括文件传输、电子邮件、远程登录等，实现不同应用程序之间的交互通信。

### http 缓存机制，常见的缓存策略

HTTP 缓存机制是一种提高网络性能和减少带宽使用的技术。

它通过缓存 Web 服务器的响应，并在下一次请求相同 URL 时返回缓存的响应，从而避免不必要的网络请求。

常见的 HTTP 缓存策略包括**强制缓存**和**协商缓存**。

**强制缓存**：第一次请求资源时，服务器返回的 HTTP 响应头中带有缓存时间，浏览器根据时间判断是否从缓存中读取，若未过期，则直接从缓存中读取，否则重新请求资源。

- `Expires`：在 HTTP/1.0 中，服务器通过在响应头中设置 Expires 字段，告诉客户端资源的过期时间，客户端可以在该时间之前从缓存中读取资源。缺点是当服务器时间与客户端时间不同步时，可能导致缓存不起作用。
- `Cache-Control`：在 HTTP/1.1 中，Cache-Control 是最重要的缓存控制字段，它可以控制缓存的方式、过期时间、重新验证等。常见的 Cache-Control 字段包括 max-age、no-cache、no-store、must-revalidate 等。

**协商缓存**：在请求数据时，浏览器会先向服务器发送一个请求，服务器会比较请求的资源的 ETag 或 Last-Modified 是否发生改变，如果未发生改变，则返回 304 状态码，告诉浏览器直接使用缓存数据。

- `ETag`：在每个响应头中，服务器会生成一个 ETag 值，客户端请求时会携带上次请求返回的 ETag 值，服务器可以通过比较这两个值来判断是否需要返回新的响应。ETag 值通常是由服务器生成的一些资源信息的哈希值或版本号。
- `Last-Modified`：在每个响应头中，服务器会返回资源的最后修改时间，客户端可以通过 If-Modified-Since 字段将上次请求返回的时间戳发送给服务器，服务器可以根据时间戳判断是否需要返回新的响应。

常见的缓存策略包括：

- 缓存静态资源，如图片、CSS 和 JS 等。
- 设置缓存头信息，如 Expires 和 Cache-Control 等。
- 使用协商缓存，如 ETag 和 Last-Modified 等。
- 使用 CDN 加速服务。
- 动态更新缓存数据，如利用 ajax 或 WebSocket 动态获取数据并更新缓存。
- 优化缓存策略，如选择合适的缓存时间、合理配置缓存机制等。

### https 缓存机制

HTTPS 缓存与 HTTP 缓存机制类似，但是由于 HTTPS 的安全性，所以其缓存机制比 HTTP 缓存机制要严格一些。

HTTPS 缓存的主要区别是：

1. HTTPS 中使用的是加密传输，因此缓存的内容需要加密存储，避免信息泄露。
2. HTTPS 中使用的证书具有一定的有效期，在证书有效期内浏览器可以缓存证书，避免重复验证证书的过程，提高访问速度。
3. HTTPS 缓存中还涉及到安全相关的策略，如 HSTS（Strict-Transport-Security）和 HPKP（Public-Key-Pins），可以避免中间人攻击，提高安全性。

常见的 HTTPS 缓存策略包括：

1. 强制缓存：与 HTTP 缓存一致，使用 Expires 和 Cache-Control 两个头信息控制缓存时间。
2. 协商缓存：与 HTTP 缓存一致，使用 Last-Modified 和 ETag 头信息进行缓存协商。
3. HSTS：HTTP Strict Transport Security（HSTS）可以强制客户端只使用 HTTPS 进行访问，在一定程度上避免了中间人攻击。
4. HPKP：HTTP Public Key Pinning（HPKP）可以指定服务器使用的公钥，避免了中间人攻击和证书欺骗。

### http 和 https 区别

HTTP（Hypertext Transfer Protocol）和 HTTPS（Hypertext Transfer Protocol Secure）是两种常见的网络协议，它们之间的主要区别在于安全性和加密。

1. **安全性**：HTTP 协议是明文传输，数据不加密，缺乏安全性。HTTPS 协议通过 SSL/TLS 协议对数据进行加密传输，防止数据被窃听和篡改，提高了数据的安全性。
2. **端口**：HTTP 协议使用 80 端口，而 HTTPS 协议则使用 443 端口。
3. **证书**：HTTPS 协议需要使用数字证书，用于验证网站的身份，防止恶意伪造网站。
4. **性能**：由于 HTTPS 协议需要进行加密和解密操作，因此比 HTTP 协议性能稍差。

### 跨域是什么，给出解决方案

跨域是指在浏览器的同源策略下，访问另一个域名下的资源。

**跨域问题**：由于同源的限制，出现无法访问的情况。

**同源策略**：浏览器只允许当前网页向同一域名或子域名下发起请求，而不允许向其他域名下发起请求。

跨域问题会在以下情况出现：

- **不同域名**：当在网页中发起一个请求时，如果该请求的域名和当前网页所在的域名不一致，就会产生跨域问题。
- **子域名之间**：即使是在同一个主域名下，不同的子域名之间也被视为不同的域名，会出现跨域问题。
- **端口不同**：不同的端口号也被视为不同的域名，会产生跨域问题。
- **协议不同**：当一个网页通过 HTTPS 协议请求 HTTP 协议的资源，或者反之，也会出现跨域问题。

> 跨域问题只存在于浏览器端，而不是服务器端。

解决方案

1. `JSONP`：利用 `<script>` 标签的跨域特性，通过动态创建 `<script>` 标签来加载数据，并指定回调函数，从而实现跨域请求。缺点是只能实现 GET 请求，且存在安全风险，容易受到 XSS 攻击。
2. `CORS`：跨域资源共享（Cross-Origin Resource Sharing）， W3C 标准，让服务器支持跨域请求。浏览器会在请求头中加上 **Origin 字段**，服务器根据这个字段来判断是否允许跨域请求，并在响应头中加上 `Access-Control-Allow-Origin、Access-Control-Allow-Headers` 字段分别指定允许的来源和允许哪些自定义请求头。缺点是在老旧**浏览器兼容性**问题，**头信息不易管理**。
3. `代理`：通过服务器来转发请求和响应，绕过浏览器的同源策略限制。例如，在本地开发环境下，可以使用代理服务器转发请求到后端接口，从而实现跨域请求。缺点是会**消耗更多的服务器资源**和**存在安全问题**（代理服务器可能会泄露信息）。

### XSS 和 CSRF

`XSS`：`Cross-Site Scripting`,`跨域脚本攻击`，一般指的是有人往网站注入恶意脚本，使之在网页中运行，从而盗取 cookie 等信息可达到以下攻击：

- 获取页面数据，如 DOM、cookie、LocalStorage
- DOS 攻击，发送合理请求，占用服务器资源，使用户无法正常访问服务器
- 破坏页面结构
- 流量劫持（将链接指向某网站）

**防御**：对存储到后端的数据进行转义，禁止`script`这种类似的脚本数据存储

`CSRF`：`Cross-Site Request Forgery`，跨站请求伪造 ，攻击者诱导用户进入一个第三方网站，然后在第三方网站发送请求，同时会带走用户现有的登录状态，从而冒充用户执行请求操作

本质是利用 Cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充

**防御**

**同源检测**： 服务端对请求头中的 origin 和 referer 进行检测，但是这两个字段也可以伪造

**使用 Token**： Token 与 Cookie 不同的就是，Token 是可以用户选择性发送，Cookie 是主动携带

**Samesite**： 设置 Cookie 的 Samesite 为严格模式，限制不被第三方网站使用 Samesite

### 跨域时携带 cookie 如何做

在跨域请求中携带 Cookie 是一个常见的需求，但由于浏览器的同源策略限制，不同域名下的 JavaScript 脚本无法直接访问另一个域名下的 Cookie。

以下是一些解决方案：

1. CORS：使用 CORS（Cross-Origin Resource Sharing，跨域资源共享）机制来允许浏览器发送跨域请求，并且在服务端设置响应头来控制请求的访问权限。通过在服务端设置 `Access-Control-Allow-Credentials: true`，表示允许跨域请求携带 Cookie。
2. 反向代理：使用反向代理服务器将请求代理到同一域名下，这样就可以携带 Cookie 了。例如，将所有跨域请求都代理到同一域名下的 `/api` 路径下。
3. 前端设置 `withCredentials` 属性：前端设置 `withCredentials` 属性为 `true`，表示允许跨域请求携带 Cookie。但需要注意，这种方式需要服务端设置 `Access-Control-Allow-Origin` 为具体的域名，而不能设置为通配符 `*`。

在携带 Cookie 的跨域请求中，还需要同时设置 `Access-Control-Allow-Origin` 和 `Access-Control-Allow-Credentials` 两个响应头，才能让浏览器正常处理跨域请求，并且返回 Cookie。

> 注意：服务端返回的 Cookie 存在敏感信息，需要进行加密处理，并且只在 HTTPS 安全协议下传输，以避免信息泄露。

## 比较篇

### get 和 post 区别

**幂等：** get 用于获取资源，不管调用多少次接口，结果都不会改变，所以是幂等的。post 会对资源本身产生影响，每次调用都会有新的资源产生，因此不满足幂等性

**应用场景：** get 获取资源，post 用来提交资源

**缓存：** get 一般会做缓存，post 不做缓存

**传参：** get 只能传字符串拼接，post 可以请求体、字符串拼接

**传参长度：** get 传参是 url 拼接，所以会因为浏览器限制 url 长度，而导致传参长度被限制

**参数类型：** get 只允许传 ASCII 字符，post 支持文件、图片、表单、JSON 等

**安全性：** 都不安全

> 幂等：一次请求和多次请求的效果相同

### HTTP1.0 与 HTTP1.1 的区别

- **连接：** 1.0 非持久连接，1.1 持久连接，多个 http 请求可复用同一个 TCP 连接
- **资源请求：** 1.1 引入了 range 头，允许只请求资源的某个部分
- **缓存：** 1.0 使用`Expire、If-Modified-Since`来当做缓存头；1.1 使用`Etag、If-None-Match、If-Match`
- **Host：** 1.1 新赠 Host 请求头，用来表示请求服务器的域名
- **方法：** 1.1 新增`PUT、HEAD、OPTIONS`等方法

### HTTP1.1 与 HTTP2.0 的区别

- **二进制协议：** 2.0 头信息和数据体都是二进制，统称为“帧”，是**多路复用**的基础
- **多路复用：** 2.0 复用 TCP 连接，同一个 TCP 连接中，可发多个请求或回应，这就解决了**队头阻塞**问题
- **数据流：** 2.0 将每个请求或回应的所有数据包统称为一个数据流，每一个数据流都有独一无二的编号 ID，用于数据传输时的区分
- **头信息压缩：** 2.0 维护一张**头信息表**，所有头字段信息都会记录在这张表里，发送时只需要发送对应的 key 就行，大大节省空间。为啥这么做呢？你想想，如果多个 header 内容都一样，照样发送的话，是不是很浪费空间
- **服务器推送：** 2.0 可提前向客户端推送静态资源，这样客户端页面的加载延迟就会大大减少

### TCP 和 UDP ，Websocket 用哪一种

TCP 和 UDP 是两种网络传输协议，它们在网络传输中有着不同的应用场景和特点。

`TCP`（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输协议。

TCP 协议在传输数据之前，需要先建立一个连接，然后才能进行数据的传输。在数据传输过程中，TCP 会对数据进行拆分、排序、确认等操作，确保数据的可靠性和完整性，从而保证数据的正确传输。

`UDP`（User Datagram Protocol，用户数据报协议）是一种无连接的、不可靠的、基于数据包的传输协议。

UDP 协议直接传输数据包。在传输过程中，UDP 不会对数据进行校验，因此数据的传输可能存在丢包和重复等问题。

它们的**主要区别**在于：

1. **可靠性**：TCP 是一种面向连接的协议，提供可靠的数据传输；而 UDP 是一种面向无连接的协议，不保证数据传输的可靠性。
2. **速度**：由于 TCP 在传输数据时要进行各种确认和校验，因此会有一定的延迟；而 UDP 不需要进行这些操作，因此速度更快。
3. **传输单位**：TCP 是一种面向流的协议，传输的单位是数据流；而 UDP 是一种面向报文的协议，传输的单位是数据报文。

TCP 适用于对可靠性要求比较高的应用，如文件传输、电子邮件等；

UDP 适用于对实时性要求比较高的应用，如音视频传输、在线游戏等。

Websocket 是一种基于 TCP 协议的全双工通信协议，可以在客户端和服务器之间建立持久连接，实现实时通信。因为 Websocket 基于 TCP 协议，可以保证数据的可靠性和完整性，同时又具有实时性。虽然 UDP 协议在实时性上更有优势，但是在可靠性和数据传输完整性方面不如 TCP 协议，因此不适用于 Websocket 通信。

### 数据报文和数据流

**数据报文**（Datagram）是指按照一定格式打包好的单个数据包，每个数据报文都包含了源地址、目的地址、长度等信息。数据报文传输时不保证有序到达，也不保证一定到达，丢包情况较为常见。UDP 协议就是基于数据报文传输的，UDP 传输方式简单，速度快，但不保证数据可靠性和有序性，适用于一些要求实时性高但可靠性要求不高的应用，比如视频、语音等。

**数据流**（Stream）则是指将数据分成若干个大小不等的块（也可以是按字节分割），通过序列号和确认应答机制来保证数据可靠到达并保持有序。TCP 协议就是基于数据流传输的，TCP 协议提供了数据可靠性和有序性保证，适用于一些要求数据传输可靠性和稳定性的应用，比如网页、文件传输等。

## 收集篇

### 常见 HTTP 请求头

**请求头**

**Accept：** 浏览器能够处理的内容类型

**Accept-Charset：** 浏览器能够显示的字符集

**Accept-Encoding：** 浏览器能够处理的压缩编码

**Accept-Language：** 浏览器当前设置的语言

**Connection：** 浏览器与服务区之间的连接类型

**Cookie：** 当前页面设置的 Cookie

**Host：** 发送请求的域名

**Referer：** 发送请求的页面 URL

**User-Agent：** 浏览器的用户代理字符串

**响应头**

**Date：** 消息发送的时间

**server：** 服务器名称

**Connection：** 浏览器与服务器之间的连接类型

**Cache-Control：** HTTP 强缓存

**Content-Type：** 数据类型

### http-only 有什么用

HTTP-only 是一种 cookie 标志，它指示浏览器**只能通过 HTTP 或 HTTPS 协议来访问 cookie**，**不能通过 JavaScript 或其他脚本访问**。主要是为了保护用户的 cookie，防止被一些恶意脚本窃取和利用。

### TCP 在连接时会出现拥塞和粘包的问题，要怎么解决粘包的问题

TCP 在传输数据时，为了提高效率，往往会将**多个小数据包合并成一个大的数据包进行传输**，这就是 TCP 粘包的问题。

常见粘包问题解决方案如下：

1. **包头+包体**：在发送数据时，在数据包的头部加上一个固定长度的数据，表示这个数据包中的数据长度，接收端可以根据这个长度来划分每个数据包，从而解决粘包的问题。
2. **定长包**：在发送数据时，将每个数据包的长度固定为一个常量值，这样接收端就可以根据这个常量值来划分每个数据包，从而解决粘包的问题。
3. **特殊字符分隔**：在发送数据时，在每个数据包的结尾加上一个特殊字符，比如换行符，接收端可以根据这个特殊字符来划分每个数据包，从而解决粘包的问题。
4. 在 TCP 层面设置 **Nagle 算法**来减少小包的发送，从而降低粘包的发生概率。

### 小程序的 webSocket 和 web 端的 webSocket 有什么不同？

小程序的 WebSocket 和 Web 端的 WebSocket 的区别主要在于它们**对 API 的支持程度不同**。

小程序的 WebSocket API 是基于标准的 WebSocket 协议实现的，但是**受到小程序运行环境的限制**，它并不支持所有 WebSocket API。例如，小程序不支持发送和接收二进制数据，也不支持设置 HTTP 头等高级操作。

另外，小程序的 WebSocket API 与 Web 端的 WebSocket API 的使用方式也略有不同。小程序的 WebSocket API 需要通过 wx.connectSocket() 进行初始化，而 Web 端的 WebSocket API 则是通过创建 WebSocket 对象来初始化的。小程序的 WebSocket API 也提供了一些专门针对小程序开发的接口，例如 wx.onSocketMessage() 和 wx.sendSocketMessage() 等。

## 参考链接

[面试中遇到频率最高的 23 道 HTTP 面试题](https://mp.weixin.qq.com/s?__biz=Mzg2NjY2NTcyNg==&mid=2247487779&idx=1&sn=824a5c22588df339f07ea0ee97bf8644&chksm=ce4604b2f9318da4a6554626c8ebb7232f16d69f5d98a7681bed4d59daf61381fcf9997f22cc&scene=178&cur_album_id=2003210846117642242#rd)
